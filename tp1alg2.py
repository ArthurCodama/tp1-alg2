# -*- coding: utf-8 -*-
"""tp1ALG2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VCaWFr21lCkFHQ11pXLUf50n2oH8AF3-
"""

import collections
import operator
from queue import PriorityQueue
import pandas as pd
import numpy as np


# ------ Classes auxiliares

Ponto = collections.namedtuple("Ponto", ["categoria", "coordenadas"])
ArvoreBinaria = collections.namedtuple("Nodo", ["valor", "esq", "dir"])

class DistanciaPonto:
  def __init__(self, ponto, distancia):
    self.ponto = ponto
    self.distancia = distancia

  def __lt__(self, outro):
    return self.distancia < outro.distancia

# ------ Classe KdTree

class KdTree:
  def __init__(self, lista):
    self.NDimensoes = len(lista[0])
    self.kdTree = self.criarArvore(lista, 0)

  def criarArvore(self, lista, altura):
    if len(lista) == 0:
      return None
    if len(lista) == 1:
      return ArvoreBinaria(
      valor = Ponto(lista[0][0], lista[0][1]),
      esq = None,
      dir = None
    )
    
    lista.sort(key=operator.itemgetter(altura % self.NDimensoes))
    divisor = len(lista) // 2  # Mediana
    
    return ArvoreBinaria(
      valor = Ponto(lista[divisor][0], lista[divisor][1]),
      esq = self.criarArvore(lista[:divisor], altura+1),
      dir = self.criarArvore(lista[divisor:], altura+1)
    )
  
# ------ Classe KNN

class XNN:
  def __init__(self, x, treinamento, teste):
    self.x = x
    self.kdTree = KdTree(treinamento)
    self.categorias = set()
    self.teste = []
    for p in teste:
      self.categorias.add(p[0])
      self.teste.append(Ponto(p[0], p[1]))

  # Distancia euclidiana ao quadrado
  def distanciaQ(self, pontoA, pontoB):
    return sum((xiA-xiB)**2 for xiA, xiB in zip(pontoA, pontoB))

  def xVizinhosProximos(self, ponto):
    maisProximos = PriorityQueue(self.x)

    def buscaAux(arvore, altura):
      nonlocal maisProximos
      
      if arvore is None:
        return

      # Usando a distancia negativa para inverter a ordem
      distancia = -self.distanciaQ(arvore.valor.coordenadas, ponto.coordenadas)

      if maisProximos.empty():
        maisProximos.put(DistanciaPonto(arvore.valor, distancia))
        menorDist = distancia
      else:
        cheio = maisProximos.full()
        p = maisProximos.get()

        if distancia > p.distancia:
          menorDist = distancia
          maisProximos.put(DistanciaPonto(arvore.valor, distancia))
          if not cheio:
            maisProximos.put(p)
        else:
          menorDist = p.distancia
          maisProximos.put(p)
          if not cheio:
            maisProximos.put(DistanciaPonto(arvore.valor, distancia))
      
      eixo = altura % self.kdTree.NDimensoes
      diferenca = ponto.coordenadas[eixo] - arvore.valor.coordenadas[eixo]
      if diferenca <= 0:
        perto = arvore.esq 
        longe = arvore.dir
      else:
        perto = arvore.dir 
        longe = arvore.esq
      
      buscaAux(perto, altura+1)

      if diferenca**2 < -menorDist:
        buscaAux(longe, altura+1)
    
    buscaAux(self.kdTree.kdTree, 0)

    aux = []
    while not maisProximos.empty():
      aux.append(maisProximos.get().ponto)

    return aux

  def classificador(self, ponto):
    qtdCategoria = collections.Counter(self.xVizinhosProximos(ponto))
    return qtdCategoria.most_common(1)[0][0].categoria

  def estatistica(self):
    fA = vA = fB = vB = 0
    cat = list(self.categorias)
    for p in self.teste:
      classe = self.classificador(p)
      if classe == cat[0]:
        if classe == p.categoria:
          vA += 1
        else:
          fA += 1
      else:
        if classe == p.categoria:
          vB += 1
        else:
          fB += 1

    acuracia = (vA+vB)/(fA+vA+fB+vB)
    precisao = (vA/(vA+fA) + vB/(vB+fB)) / 2 if (vA+fA != 0 and vB+fB != 0) else (vA/(vA+fA) if vA+fA != 0 else vB/(vB+fB))
    revocacao = (vA/(vA+fB) + vB/(vB+fA)) / 2 if (vA+fB != 0 and vB+fA != 0) else (vA/(vA+fB) if vA+fB != 0 else vB/(vB+fA))

    return {
        # f"f{cat[0]}": fA,
        # f"v{cat[0]}": vA,
        # f"f{cat[1]}": fB,
        # f"v{cat[1]}": vB,
        "acuracia":  "{:.2f}%".format(acuracia*100),
        "precisao":  "{:.2f}%".format(precisao*100),
        "revocacao": "{:.2f}%".format(revocacao*100),
    }

# ------ Leitura do arquivo

# DataSets com a categoria como ultimo atributo e que possuem apenas 2 categorias
def prepararDataSet(nomeArquivo):
  df = pd.read_csv(nomeArquivo, encoding='utf-8')
  treino = df.sample(frac=0.7)
  teste = df.drop(treino.index)
  listaTreino = []
  listaTeste = []
  for r in treino.to_numpy():
    listaTreino.append((r[-1], tuple(r[:-1])))

  for r in teste.to_numpy():
    listaTeste.append((r[-1], tuple(r[:-1])))

  return (listaTreino, listaTeste)

# ------ Inicio do programa

def teste(nvizinhos=3):
  arquivos = [
    "australian.csv",
    "banana.csv",
    "bupa.csv",
    "diabetes.csv",
    "glass.csv",
    "magic.csv",
    "phoneme.csv",
    "pima.csv",
    "ring.csv",
    "saheart.csv"
  ]
  resultados = []
  for arq in arquivos:
    treino, teste = prepararDataSet(arq)
    xnn = XNN(nvizinhos, treino, teste)
    est = xnn.estatistica()

    resultados.append(est)

    print(f"Arquivo: {arq}")
    print(f"Número de vizinhos: {nvizinhos}")
    print(f"Acurácia: {est['acuracia']}")
    print(f"Precisão: {est['precisao']}")
    print(f"Revocação: {est['revocacao']}")
    print("")
  return resultados

# nomeArquivo = input("Nome arquivo: ")
# x = int(input("Numero de vizinhos a comparar: "))
# treino, teste = prepararDataSet(nomeArquivo)
# xnn = XNN(x, treino, teste)
# est = xnn.estatistica()
aux = teste()